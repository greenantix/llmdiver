"""
PR/MR Automation Feature - GitHub/GitLab Integration
Automated Pull Request and Merge Request creation with intelligent templates
"""

import asyncio
import json
import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple, Any
import aiohttp
import subprocess
import tempfile
from urllib.parse import urlparse

from ..core.config import AuraConfig
from ..llm.providers import LLMProvider
from .semantic_commits import GitAnalyzer


class PRPlatform(Enum):
    GITHUB = "github"
    GITLAB = "gitlab"
    BITBUCKET = "bitbucket"


class PRTemplate(Enum):
    FEATURE = "feature"
    BUGFIX = "bugfix"
    HOTFIX = "hotfix"
    REFACTOR = "refactor"
    DOCS = "docs"
    CHORE = "chore"


@dataclass
class PullRequestInfo:
    title: str
    body: str
    source_branch: str
    target_branch: str
    labels: List[str] = field(default_factory=list)
    assignees: List[str] = field(default_factory=list)
    reviewers: List[str] = field(default_factory=list)
    milestone: Optional[str] = None
    draft: bool = False


@dataclass
class CommitAnalysis:
    commit_hash: str
    message: str
    author: str
    date: str
    files_changed: List[str]
    insertions: int
    deletions: int
    type: str
    scope: Optional[str] = None
    breaking_change: bool = False


@dataclass
class PRMetrics:
    files_changed: int
    insertions: int
    deletions: int
    commits_count: int
    complexity_score: float
    risk_level: str


class PRAutomationSystem:
    def __init__(self, config: AuraConfig, llm_provider: LLMProvider):
        self.config = config
        self.llm_provider = llm_provider
        self.git_analyzer = GitAnalyzer(config, llm_provider)
        self.templates = self._load_templates()
        
    def _load_templates(self) -> Dict[PRTemplate, str]:
        """Load PR templates from configuration or defaults"""
        return {
            PRTemplate.FEATURE: """## ðŸš€ Feature

### Summary
{summary}

### Changes Made
{changes}

### Testing
{testing}

### Breaking Changes
{breaking_changes}

### Related Issues
{related_issues}

### Checklist
- [ ] Tests added/updated
- [ ] Documentation updated
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Ready for review

### Screenshots/Demo
{screenshots}

---
*Auto-generated by Aura PR Automation*
""",
            PRTemplate.BUGFIX: """## ðŸ› Bug Fix

### Problem Description
{problem}

### Root Cause
{root_cause}

### Solution
{solution}

### Files Changed
{files_changed}

### Testing
{testing}

### Regression Risk
{regression_risk}

### Related Issues
{related_issues}

### Checklist
- [ ] Bug reproduced and verified
- [ ] Fix tested thoroughly
- [ ] Edge cases considered
- [ ] No regression introduced
- [ ] Ready for review

---
*Auto-generated by Aura PR Automation*
""",
            PRTemplate.HOTFIX: """## ðŸš¨ Hotfix

### Critical Issue
{critical_issue}

### Impact
{impact}

### Quick Fix Applied
{fix_applied}

### Verification
{verification}

### Follow-up Required
{followup}

### Emergency Deployment Notes
{deployment_notes}

---
*Auto-generated by Aura PR Automation - URGENT*
""",
            PRTemplate.REFACTOR: """## â™»ï¸ Refactor

### Refactoring Goal
{goal}

### Changes Made
{changes}

### Benefits
{benefits}

### Backward Compatibility
{compatibility}

### Performance Impact
{performance}

### Testing
{testing}

---
*Auto-generated by Aura PR Automation*
""",
            PRTemplate.DOCS: """## ðŸ“š Documentation

### Documentation Updates
{updates}

### Scope
{scope}

### Changes Made
{changes}

### Related Code Changes
{code_changes}

---
*Auto-generated by Aura PR Automation*
""",
            PRTemplate.CHORE: """## ðŸ”§ Chore

### Maintenance Task
{task}

### Changes Made
{changes}

### Impact
{impact}

### Testing
{testing}

---
*Auto-generated by Aura PR Automation*
"""
        }

    async def detect_platform(self, repo_path: Path) -> Optional[PRPlatform]:
        """Detect the Git hosting platform from remote URL"""
        try:
            result = subprocess.run(
                ['git', 'remote', 'get-url', 'origin'],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True
            )
            remote_url = result.stdout.strip()
            
            if 'github.com' in remote_url:
                return PRPlatform.GITHUB
            elif 'gitlab.com' in remote_url or 'gitlab' in remote_url:
                return PRPlatform.GITLAB
            elif 'bitbucket.org' in remote_url:
                return PRPlatform.BITBUCKET
                
        except subprocess.CalledProcessError:
            pass
            
        return None

    async def analyze_branch_changes(self, repo_path: Path, source_branch: str, target_branch: str) -> List[CommitAnalysis]:
        """Analyze commits between branches"""
        try:
            # Get commit range
            result = subprocess.run(
                ['git', 'rev-list', f'{target_branch}..{source_branch}'],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True
            )
            commit_hashes = result.stdout.strip().split('\n')
            
            commits = []
            for commit_hash in commit_hashes:
                if not commit_hash:
                    continue
                    
                # Get commit info
                commit_info = subprocess.run(
                    ['git', 'show', '--format=%H|%s|%an|%ad|%d', '--name-only', '--date=iso', commit_hash],
                    cwd=repo_path,
                    capture_output=True,
                    text=True,
                    check=True
                ).stdout.strip().split('\n')
                
                if len(commit_info) < 2:
                    continue
                    
                header_parts = commit_info[0].split('|')
                if len(header_parts) < 4:
                    continue
                    
                hash_val, message, author, date = header_parts[:4]
                files_changed = [f for f in commit_info[1:] if f.strip()]
                
                # Get stats
                stats = subprocess.run(
                    ['git', 'show', '--stat', '--format=', commit_hash],
                    cwd=repo_path,
                    capture_output=True,
                    text=True,
                    check=True
                ).stdout.strip()
                
                insertions = deletions = 0
                if stats:
                    stats_lines = stats.split('\n')
                    for line in stats_lines:
                        if 'insertion' in line or 'deletion' in line:
                            parts = line.split(',')
                            for part in parts:
                                if 'insertion' in part:
                                    insertions = int(re.findall(r'\d+', part)[0]) if re.findall(r'\d+', part) else 0
                                elif 'deletion' in part:
                                    deletions = int(re.findall(r'\d+', part)[0]) if re.findall(r'\d+', part) else 0
                
                # Analyze commit type
                commit_type, scope, breaking = self._analyze_commit_message(message)
                
                commits.append(CommitAnalysis(
                    commit_hash=hash_val,
                    message=message,
                    author=author,
                    date=date,
                    files_changed=files_changed,
                    insertions=insertions,
                    deletions=deletions,
                    type=commit_type,
                    scope=scope,
                    breaking_change=breaking
                ))
                
            return commits
            
        except subprocess.CalledProcessError as e:
            print(f"Error analyzing branch changes: {e}")
            return []

    def _analyze_commit_message(self, message: str) -> Tuple[str, Optional[str], bool]:
        """Analyze commit message for type, scope, and breaking changes"""
        # Conventional commit pattern
        pattern = r'^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\([^)]+\))?(!)?: .+'
        match = re.match(pattern, message.lower())
        
        if match:
            commit_type = match.group(1)
            scope = match.group(2)[1:-1] if match.group(2) else None
            breaking = bool(match.group(3))
            return commit_type, scope, breaking
        
        # Fallback analysis
        message_lower = message.lower()
        if any(word in message_lower for word in ['add', 'implement', 'create']):
            return 'feat', None, False
        elif any(word in message_lower for word in ['fix', 'bug', 'issue']):
            return 'fix', None, False
        elif any(word in message_lower for word in ['refactor', 'restructure']):
            return 'refactor', None, False
        elif any(word in message_lower for word in ['doc', 'readme']):
            return 'docs', None, False
        else:
            return 'chore', None, False

    async def calculate_pr_metrics(self, commits: List[CommitAnalysis]) -> PRMetrics:
        """Calculate PR complexity and risk metrics"""
        if not commits:
            return PRMetrics(0, 0, 0, 0, 0.0, "low")
        
        files_changed = set()
        total_insertions = 0
        total_deletions = 0
        
        for commit in commits:
            files_changed.update(commit.files_changed)
            total_insertions += commit.insertions
            total_deletions += commit.deletions
        
        # Calculate complexity score
        file_count_factor = min(len(files_changed) / 10, 1.0)
        line_change_factor = min((total_insertions + total_deletions) / 500, 1.0)
        commit_count_factor = min(len(commits) / 20, 1.0)
        
        complexity_score = (file_count_factor + line_change_factor + commit_count_factor) / 3
        
        # Determine risk level
        if complexity_score > 0.7 or any(c.breaking_change for c in commits):
            risk_level = "high"
        elif complexity_score > 0.4:
            risk_level = "medium"
        else:
            risk_level = "low"
        
        return PRMetrics(
            files_changed=len(files_changed),
            insertions=total_insertions,
            deletions=total_deletions,
            commits_count=len(commits),
            complexity_score=complexity_score,
            risk_level=risk_level
        )

    def _determine_pr_template(self, commits: List[CommitAnalysis]) -> PRTemplate:
        """Determine the most appropriate PR template based on commits"""
        if not commits:
            return PRTemplate.CHORE
        
        type_counts = {}
        for commit in commits:
            type_counts[commit.type] = type_counts.get(commit.type, 0) + 1
        
        # Check for hotfix indicators
        if any('hotfix' in commit.message.lower() or 'urgent' in commit.message.lower() for commit in commits):
            return PRTemplate.HOTFIX
        
        # Determine primary type
        primary_type = max(type_counts, key=type_counts.get)
        
        type_mapping = {
            'feat': PRTemplate.FEATURE,
            'fix': PRTemplate.BUGFIX,
            'refactor': PRTemplate.REFACTOR,
            'docs': PRTemplate.DOCS,
            'chore': PRTemplate.CHORE,
            'style': PRTemplate.REFACTOR,
            'perf': PRTemplate.REFACTOR,
            'test': PRTemplate.CHORE
        }
        
        return type_mapping.get(primary_type, PRTemplate.CHORE)

    async def generate_pr_content(self, commits: List[CommitAnalysis], metrics: PRMetrics, template: PRTemplate) -> Dict[str, str]:
        """Generate PR title and body using LLM"""
        
        # Create context for LLM
        context = {
            'commits': [
                {
                    'message': c.message,
                    'files': c.files_changed,
                    'type': c.type,
                    'breaking': c.breaking_change
                } for c in commits
            ],
            'metrics': {
                'files_changed': metrics.files_changed,
                'insertions': metrics.insertions,
                'deletions': metrics.deletions,
                'complexity': metrics.complexity_score,
                'risk': metrics.risk_level
            }
        }
        
        # Generate title
        title_prompt = f"""
Generate a concise, descriptive pull request title based on these commits:

Commits:
{json.dumps(context['commits'], indent=2)}

Guidelines:
- Use conventional commit format when appropriate
- Keep under 72 characters
- Be specific and clear
- Focus on the main change/feature

Title:"""

        title_response = await self.llm_provider.generate_completion(title_prompt)
        title = title_response.strip().strip('"')
        
        # Generate detailed content sections
        if template == PRTemplate.FEATURE:
            content = await self._generate_feature_content(commits, metrics)
        elif template == PRTemplate.BUGFIX:
            content = await self._generate_bugfix_content(commits, metrics)
        elif template == PRTemplate.HOTFIX:
            content = await self._generate_hotfix_content(commits, metrics)
        elif template == PRTemplate.REFACTOR:
            content = await self._generate_refactor_content(commits, metrics)
        elif template == PRTemplate.DOCS:
            content = await self._generate_docs_content(commits, metrics)
        else:
            content = await self._generate_chore_content(commits, metrics)
        
        return {'title': title, **content}

    async def _generate_feature_content(self, commits: List[CommitAnalysis], metrics: PRMetrics) -> Dict[str, str]:
        """Generate feature PR content"""
        
        prompt = f"""
Analyze these commits for a feature pull request:

Commits:
{json.dumps([{'message': c.message, 'files': c.files_changed} for c in commits], indent=2)}

Generate detailed content for:
1. Summary - Brief overview of the feature
2. Changes - Key technical changes made
3. Testing - How this should be tested
4. Breaking Changes - Any breaking changes (if applicable)
5. Related Issues - Likely related issue patterns

Format as JSON with keys: summary, changes, testing, breaking_changes, related_issues
"""
        
        response = await self.llm_provider.generate_completion(prompt)
        try:
            content = json.loads(response)
            return {
                'summary': content.get('summary', 'New feature implementation'),
                'changes': content.get('changes', '- Implementation details pending'),
                'testing': content.get('testing', '- Manual testing required'),
                'breaking_changes': content.get('breaking_changes', 'None'),
                'related_issues': content.get('related_issues', 'TBD'),
                'screenshots': 'TBD - Add screenshots/demos if applicable'
            }
        except json.JSONDecodeError:
            return {
                'summary': 'New feature implementation',
                'changes': '- See commit history for details',
                'testing': '- Manual testing required',
                'breaking_changes': 'None',
                'related_issues': 'TBD',
                'screenshots': 'TBD'
            }

    async def _generate_bugfix_content(self, commits: List[CommitAnalysis], metrics: PRMetrics) -> Dict[str, str]:
        """Generate bugfix PR content"""
        
        prompt = f"""
Analyze these commits for a bug fix pull request:

Commits:
{json.dumps([{'message': c.message, 'files': c.files_changed} for c in commits], indent=2)}

Generate content for:
1. Problem - What bug was being fixed
2. Root Cause - Technical cause of the issue
3. Solution - How the fix addresses the problem
4. Testing - How to verify the fix
5. Regression Risk - Risk assessment

Format as JSON with keys: problem, root_cause, solution, testing, regression_risk
"""
        
        response = await self.llm_provider.generate_completion(prompt)
        try:
            content = json.loads(response)
            return {
                'problem': content.get('problem', 'Bug fix - see commits for details'),
                'root_cause': content.get('root_cause', 'Under investigation'),
                'solution': content.get('solution', '- See commit changes'),
                'files_changed': '- ' + '\n- '.join(set(f for c in commits for f in c.files_changed)),
                'testing': content.get('testing', '- Manual verification required'),
                'regression_risk': content.get('regression_risk', f'Risk Level: {metrics.risk_level}'),
                'related_issues': 'TBD'
            }
        except json.JSONDecodeError:
            return {
                'problem': 'Bug fix - see commits for details',
                'root_cause': 'Under investigation',
                'solution': '- See commit changes',
                'files_changed': '- ' + '\n- '.join(set(f for c in commits for f in c.files_changed)),
                'testing': '- Manual verification required',
                'regression_risk': f'Risk Level: {metrics.risk_level}',
                'related_issues': 'TBD'
            }

    async def _generate_hotfix_content(self, commits: List[CommitAnalysis], metrics: PRMetrics) -> Dict[str, str]:
        """Generate hotfix PR content"""
        return {
            'critical_issue': 'Critical production issue - see commits',
            'impact': 'High priority fix required',
            'fix_applied': '- ' + '\n- '.join(c.message for c in commits),
            'verification': '- Immediate testing required',
            'followup': '- Post-deployment monitoring needed',
            'deployment_notes': 'Deploy immediately after approval'
        }

    async def _generate_refactor_content(self, commits: List[CommitAnalysis], metrics: PRMetrics) -> Dict[str, str]:
        """Generate refactor PR content"""
        return {
            'goal': 'Code refactoring and improvement',
            'changes': '- ' + '\n- '.join(c.message for c in commits),
            'benefits': '- Improved code quality\n- Better maintainability',
            'compatibility': 'Backward compatible',
            'performance': 'No performance impact expected',
            'testing': '- Existing tests should pass\n- Manual verification recommended'
        }

    async def _generate_docs_content(self, commits: List[CommitAnalysis], metrics: PRMetrics) -> Dict[str, str]:
        """Generate documentation PR content"""
        return {
            'updates': 'Documentation improvements',
            'scope': '- ' + '\n- '.join(set(f for c in commits for f in c.files_changed if f.endswith(('.md', '.rst', '.txt')))),
            'changes': '- ' + '\n- '.join(c.message for c in commits),
            'code_changes': 'Documentation only - no code changes'
        }

    async def _generate_chore_content(self, commits: List[CommitAnalysis], metrics: PRMetrics) -> Dict[str, str]:
        """Generate chore PR content"""
        return {
            'task': 'Maintenance and housekeeping',
            'changes': '- ' + '\n- '.join(c.message for c in commits),
            'impact': 'Low impact maintenance changes',
            'testing': '- Basic functionality verification'
        }

    async def create_github_pr(self, repo_info: Dict[str, str], pr_info: PullRequestInfo, token: str) -> Dict[str, Any]:
        """Create GitHub pull request via API"""
        
        api_url = f"https://api.github.com/repos/{repo_info['owner']}/{repo_info['repo']}/pulls"
        
        headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
        }
        
        data = {
            'title': pr_info.title,
            'body': pr_info.body,
            'head': pr_info.source_branch,
            'base': pr_info.target_branch,
            'draft': pr_info.draft
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(api_url, headers=headers, json=data) as response:
                if response.status == 201:
                    pr_data = await response.json()
                    
                    # Add labels if specified
                    if pr_info.labels:
                        await self._add_github_labels(session, repo_info, pr_data['number'], pr_info.labels, token)
                    
                    # Add assignees if specified
                    if pr_info.assignees:
                        await self._add_github_assignees(session, repo_info, pr_data['number'], pr_info.assignees, token)
                    
                    return {
                        'success': True,
                        'pr_url': pr_data['html_url'],
                        'pr_number': pr_data['number'],
                        'data': pr_data
                    }
                else:
                    error_data = await response.json()
                    return {
                        'success': False,
                        'error': error_data.get('message', 'Unknown error'),
                        'status': response.status
                    }

    async def _add_github_labels(self, session: aiohttp.ClientSession, repo_info: Dict[str, str], pr_number: int, labels: List[str], token: str):
        """Add labels to GitHub PR"""
        url = f"https://api.github.com/repos/{repo_info['owner']}/{repo_info['repo']}/issues/{pr_number}/labels"
        headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json'
        }
        
        await session.post(url, headers=headers, json={'labels': labels})

    async def _add_github_assignees(self, session: aiohttp.ClientSession, repo_info: Dict[str, str], pr_number: int, assignees: List[str], token: str):
        """Add assignees to GitHub PR"""
        url = f"https://api.github.com/repos/{repo_info['owner']}/{repo_info['repo']}/issues/{pr_number}/assignees"
        headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json'
        }
        
        await session.post(url, headers=headers, json={'assignees': assignees})

    def _parse_github_repo(self, remote_url: str) -> Dict[str, str]:
        """Parse GitHub repository owner and name from remote URL"""
        patterns = [
            r'github\.com[:/]([^/]+)/([^/]+?)(?:\.git)?/?$',
            r'git@github\.com:([^/]+)/([^/]+?)(?:\.git)?/?$'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, remote_url)
            if match:
                return {
                    'owner': match.group(1),
                    'repo': match.group(2)
                }
        
        raise ValueError(f"Could not parse GitHub repository from URL: {remote_url}")

    async def auto_create_pr(
        self,
        repo_path: Path,
        source_branch: str,
        target_branch: str = "main",
        token: Optional[str] = None,
        auto_labels: bool = True,
        draft: bool = False
    ) -> Dict[str, Any]:
        """Automatically create a pull request with intelligent content generation"""
        
        try:
            # Detect platform
            platform = await self.detect_platform(repo_path)
            if not platform:
                return {'success': False, 'error': 'Could not detect Git hosting platform'}
            
            if platform != PRPlatform.GITHUB:
                return {'success': False, 'error': f'{platform.value} not yet supported'}
            
            # Analyze changes
            commits = await self.analyze_branch_changes(repo_path, source_branch, target_branch)
            if not commits:
                return {'success': False, 'error': 'No commits found between branches'}
            
            # Calculate metrics
            metrics = await self.calculate_pr_metrics(commits)
            
            # Determine template
            template = self._determine_pr_template(commits)
            
            # Generate content
            content = await self.generate_pr_content(commits, metrics, template)
            
            # Format PR body
            template_str = self.templates[template]
            pr_body = template_str.format(**content)
            
            # Determine labels
            labels = []
            if auto_labels:
                primary_type = max((c.type for c in commits), key=lambda t: sum(1 for c in commits if c.type == t))
                labels.append(primary_type)
                labels.append(f"complexity-{metrics.risk_level}")
                
                if any(c.breaking_change for c in commits):
                    labels.append("breaking-change")
            
            # Create PR info
            pr_info = PullRequestInfo(
                title=content['title'],
                body=pr_body,
                source_branch=source_branch,
                target_branch=target_branch,
                labels=labels,
                draft=draft
            )
            
            # Get repository info
            remote_url = subprocess.run(
                ['git', 'remote', 'get-url', 'origin'],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True
            ).stdout.strip()
            
            repo_info = self._parse_github_repo(remote_url)
            
            # Use token from config if not provided
            if not token:
                token = self.config.get('github_token')
                if not token:
                    return {'success': False, 'error': 'GitHub token required'}
            
            # Create PR
            result = await self.create_github_pr(repo_info, pr_info, token)
            
            if result['success']:
                result.update({
                    'template_used': template.value,
                    'metrics': metrics,
                    'commits_analyzed': len(commits)
                })
            
            return result
            
        except Exception as e:
            return {'success': False, 'error': str(e)}

    async def create_pr_from_current_branch(self, repo_path: Path, **kwargs) -> Dict[str, Any]:
        """Create PR from current branch to main/master"""
        
        try:
            # Get current branch
            current_branch = subprocess.run(
                ['git', 'branch', '--show-current'],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True
            ).stdout.strip()
            
            if not current_branch:
                return {'success': False, 'error': 'Could not determine current branch'}
            
            # Determine target branch
            target_candidates = ['main', 'master', 'develop']
            target_branch = None
            
            for candidate in target_candidates:
                try:
                    subprocess.run(
                        ['git', 'show-ref', '--verify', f'refs/heads/{candidate}'],
                        cwd=repo_path,
                        check=True,
                        capture_output=True
                    )
                    target_branch = candidate
                    break
                except subprocess.CalledProcessError:
                    continue
            
            if not target_branch:
                return {'success': False, 'error': 'Could not determine target branch'}
            
            if current_branch == target_branch:
                return {'success': False, 'error': f'Cannot create PR from {target_branch} to itself'}
            
            return await self.auto_create_pr(repo_path, current_branch, target_branch, **kwargs)
            
        except subprocess.CalledProcessError as e:
            return {'success': False, 'error': f'Git command failed: {e}'}